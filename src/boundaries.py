'''
Author: Amanda Rowley
Last Updated: 08/13/2024

Functions for handling boundary conditions. Contains functionality for three boundary types at the surface - Dirichlet (constant pressure, values determined by initial condition set in main.py), 
Neumann (constant flux, values set in global variable g_top), and Forced (varied flux, values determined by input.txt) - and three boundary types at the base Dirichlet (set by initial condition),
Neumann (set by g_bottom), and Free Drainage. Global variables top_bound and bottom_bound must be set according to desired boundary type.
'''

from fenics import *
from dolfin import *
import sys

from soil_hydraulics_VG import K_funct, C_funct, theta

# Global variables to set boundary type and constant flux value (if applicable) ===================================
# [0 = Dirichlet, 1 = Neumann, 2 = Forced]
top_bound = 2

# [0 = Dirichlet, 1 = Neumann, 2 = Free Drainage]
bottom_bound = 2

# Neumann Boundary Conditions
g_top = 0.0000                             # Constant flux at the surface (per time unit.)
g_bottom = 0.000                          # Constant flux at the bottom of the soil column (per time unit.)

Neumann_bounds = [float(g_top), float(g_bottom)]

# Function to read in comma delimited precipitation/evaporation text file generated by Main_Generate_Precip_PET_Hydrus_Inputs.m
def get_forcing():

    if len(sys.argv) < 2:
        print('Insufficient arguments. To run program: python <richards.py> <forcing.txt>')
        quit()

    forcing_filename = sys.argv[1]
    forcing_file = open(forcing_filename)
    forcing_content = forcing_file.readlines()
    
    return forcing_content


# Return flux at surface and base of column for a given day - note that Dirichlet (fix pressure bounds) are set by the initial condition in main.py, and have no flux value.
def get_bounds(current_day, h_m, nx, max_x, min_x, params, V, dt):

    if top_bound == 0: # These are handled differently!!!!
        g_top = 0.00
        gt_top = 0.00
    elif top_bound == 1:
        g_top, gt_top = top_neumann(Neumann_bounds, dt)
    elif top_bound == 2:
        g_top, gt_top, dt = top_forced(current_day, dt, dt)

    if bottom_bound == 0:  # These are handled differently!!!!
        g_bottom = 0.00
    elif bottom_bound == 1:
        g_bottom = bottom_neumann(Neumann_bounds, dt)
    elif bottom_bound == 2:
        g_bottom = bottom_free_drain(h_m, nx, max_x, min_x, params, V, dt)   

    return g_top, gt_top, g_bottom

def get_type_bounds():
    return top_bound, bottom_bound

# Top Boundaries ===================================================================================================================================

def top_neumann(Neumann_bounds, dt):                                                                            # Bottom Boundary: Neumann Condition
    g_top = Neumann_bounds[0]
    gt_top = 0.00

    return g_top, gt_top


def top_forced(current_day, dt_r = 240, dt_e = 1800):                                                           # Top Boundary: Rainfall / Evaporation

    forcing_content = get_forcing()

    rainfall = float((forcing_content[current_day-1].split(','))[1])/10                                         
    evaporation = float((forcing_content[current_day-1].split(','))[3])/10
    transpiration = float((forcing_content[current_day-1].split(','))[4])/10

    epsilon = 0.000000001

    if rainfall > epsilon:
        dt = dt_r
        rain_per_sec = rainfall/86400
        rain_per_min = (rainfall/1440)

        g_top = rain_per_min
        gt_top = 0.00

    else:
        dt = dt_e
        evap_per_sec = evaporation/86400
        evap_per_min = (evaporation/1440)
        
        g_top = evap_per_min

        # # Transpiration functionality is questionable - use at own risk.
        # trans_per_min = (transpiration/1440)
        # trans_per_dx = trans_per_min/51
        # gt_top = trans_per_dx
        gt_top = 0.0

    return -g_top, gt_top, dt


# Bottom Boundaries =======================================================================================================================================

def bottom_neumann(Neumann_bounds, dt):                                                                             # Bottom Boundary: Neumann Condition
    g_bottom = Neumann_bounds[1]
    return g_bottom


def bottom_free_drain(h_m, nx, max_x, min_x, params, V, dt):                                                        # Bottom Boundary: Free Drainage Condition 

    dh = (h_m.vector().get_local())[0]-(h_m.vector().get_local())[1]
    dz = (max_x - min_x)/nx

    K_theta_N_min_1 = K_funct(h_m, V, nx)[1]
    K_theta_N = K_funct(h_m, V, nx)[0]

    return -K_theta_N
    